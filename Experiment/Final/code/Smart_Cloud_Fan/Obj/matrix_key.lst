C51 COMPILER V9.02   MATRIX_KEY                                                            12/19/2022 09:56:56 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MATRIX_KEY
OBJECT MODULE PLACED IN ..\Obj\matrix_key.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE ..\Api\matrix_key.c BROWSE INCDIR(..\Api;..\Public;..\User) DEBUG OBJECTEXT
                    -END PRINT(..\Obj\matrix_key.lst) OBJECT(..\Obj\matrix_key.obj)

line level    source

   1          #include "matrix_key.h"
   2          
   3          /*******************************
   4          single press return value: 1~16, 250Hz beep for 0.1s
   5          1  2  3  4
   6          5  6  7  8
   7          9  10 11 12
   8          13 14 15 16
   9          long press retuen value: 17~32, add 16 to the single press return value, 500Hz beep for 0.3s
  10          no press: return 0xff
  11          *******************************/
  12          bit flag_matrix_key = 0;
  13          unsigned char flag_matrix_key_pressed = 0;
  14          unsigned char matrix_key_hold_cnt=0;
  15          bit flag_key_long_press_output_1s = 0;
  16          bit flag_buzzer_250Hz=0;
  17          bit flag_buzzer_500Hz=0;
  18          unsigned char matrix_key_scan()
  19          {
  20   1              unsigned char key_value=0xff;
  21   1              static unsigned char j=0, k=0;
  22   1              static xdata unsigned char key_flag[4]={0,0,0,0};  // 倒数第几位为0表示第几个按键没按下
  23   1              static xdata unsigned char buff[4][4]={{0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff},
             -{0xff,0xff,0xff,0xff}};  // 消抖，连续采样8次，8次采样值均相同才视为稳定
  24   1              static xdata unsigned char key_press_no[4]={0,0,0,0};  // 单击后记录是哪个按键单击，没有则为0
  25   1              static xdata unsigned char key_hold_no[4]={0,0,0,0};  // 已经长按的按键，没有则为0
  26   1              unsigned char i;
  27   1      
  28   1              switch(j)  // 换行扫描，对应行输入置0，低电平
  29   1              {
  30   2                      case 0: P1 = 0x7f; break;
  31   2                      case 1: P1 = 0xbf; break;
  32   2                      case 2: P1 = 0xdf; break;
  33   2                      case 3: P1 = 0xef; break;
  34   2              }
  35   1      
  36   1              if (flag_matrix_key == 1)  // 每2ms检测一次
  37   1              {
  38   2                      flag_matrix_key = 0;
  39   2                      buff[j][0] = (buff[j][0]<<1) | matrix_key_col_1;
  40   2                      buff[j][1] = (buff[j][1]<<1) | matrix_key_col_2;
  41   2                      buff[j][2] = (buff[j][2]<<1) | matrix_key_col_3;
  42   2                      buff[j][3] = (buff[j][3]<<1) | matrix_key_col_4;                
  43   2      
  44   2                      for (i=0;i<4;i++)  //循环检测四个按键
  45   2                      {
  46   3                              if ( ((key_flag[j]>>i)&0x01)==0x00 && buff[j][i]==0x00 )  // 当前flag没按下，buff已经稳定
  47   3                              {
  48   4                                      key_flag[j] |= 0x01<<i;  // 置1，表示按键按下
  49   4                                      key_value = 4*j+i + 1;
  50   4                              }
  51   3                              else if (buff[j][i]==0xff) key_flag[j] &= ~(0x01<<i);  // 置0，表示按键松开
  52   3                      }
  53   2      
C51 COMPILER V9.02   MATRIX_KEY                                                            12/19/2022 09:56:56 PAGE 2   

  54   2                      // 判断长按             
  55   2                      if (key_hold_no[k]!=0)  // 已经有按键处于长按状态
  56   2                      {
  57   3                              if (key_value != key_hold_no[k])        // 键值跟之前不一样或者没有按键按下
  58   3                              {
  59   4                                      key_hold_no[k] = 0;
  60   4                                      key_press_no[k] = 0;    
  61   4                              }
  62   3                              else  // 仍然长按中
  63   3                              {
  64   4                                      key_value = key_hold_no[k] + 16;
  65   4                                      key_flag[j] &= ~(0x01<<((key_value-1)%4));      // 置0，表示按键松开，才能再次检测单击
  66   4                              }
  67   3                      } else if (key_value!=0xff)      // 目前没有长按且有按键按下
  68   2                      {       
  69   3                              if ( ( (flag_matrix_key_pressed>>k)&0x01 ) == 0 )        // 为0，第一次单击
  70   3                              {
  71   4                                      key_press_no[k] = key_value;  // 记录单击的按键
  72   4                                      matrix_key_hold_cnt = 0;  // 清零计数器
  73   4                                      flag_matrix_key_pressed |= (1<<k);  // 置1，计数器开始计数
  74   4                                      key_flag[j] &= ~(0x01<<((key_value-1)%4));      // 置0，表示按键松开，才能再次检测单击
  75   4                              }else  // 之前已经单击了
  76   3                              {
  77   4                                      if (key_value == key_press_no[k])  // 单击过了同一按键
  78   4                                      {
  79   5                                              key_flag[j] &= ~(0x01<<((key_value-1)%4));      // 置0，表示按键松开，才能再次检测单击
  80   5                                              key_value = 0xff;  // 单击过了不再返回键值
  81   5                                      } else  // 新的单击
  82   4                                      {
  83   5                                              key_press_no[k] = key_value;  // 记录单击的按键
  84   5                                              matrix_key_hold_cnt = 0;  // 清零计数器重新开始计数
  85   5                                              key_flag[j] &= ~(0x01<<((key_value-1)%4));      // 置0，表示按键松开，才能再次检测单击
  86   5                                      }
  87   4                              }
  88   3                              
  89   3                              if (matrix_key_hold_cnt>=250)  // 判断为长按，500ms
  90   3                              {
  91   4                                      flag_matrix_key_pressed &= ~(1<<k);  // 置0，停止计数
  92   4                                      key_hold_no[k] = key_press_no[k];        // 记录长按的按键
  93   4                                      key_value = key_hold_no[k] + 16;  // 返回键值+16代表长按
  94   4                                      flag_buzzer_500Hz = 1;  // 长按开始时音效                                                       
  95   4                              }
  96   3                      } else  // 0xff，松开
  97   2                      {
  98   3                              key_hold_no[k] = 0;
  99   3                              key_press_no[k] = 0;
 100   3                              flag_matrix_key_pressed &= ~(1<<k);     
 101   3                      }
 102   2      
 103   2                      if (key_value>=17 && key_value<=32)  // 长按每1s返回一次键值
 104   2                      {
 105   3                              if (flag_key_long_press_output_1s == 1)
 106   3                                      flag_key_long_press_output_1s = 0;
 107   3                              else key_value = 0xff; 
 108   3                      }
 109   2      
 110   2                      k++;
 111   2                      if (k==4) k = 0;  // 长按检测，每四次才会扫描同一行             
 112   2                      j++;
 113   2                      if (j==4) j = 0;  // 换行扫描
 114   2              }
 115   1      
C51 COMPILER V9.02   MATRIX_KEY                                                            12/19/2022 09:56:56 PAGE 3   

 116   1              if (key_value < 17) flag_buzzer_250Hz = 1;      // 单击音效
 117   1              return key_value;
 118   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    804    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     28    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
