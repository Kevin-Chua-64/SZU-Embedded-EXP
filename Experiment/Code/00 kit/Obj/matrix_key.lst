C51 COMPILER V9.02   MATRIX_KEY                                                            12/16/2022 23:19:34 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MATRIX_KEY
OBJECT MODULE PLACED IN ..\Obj\matrix_key.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE ..\Api\matrix_key.c BROWSE INCDIR(..\Api;..\Public;..\User) DEBUG OBJECTEXT
                    -END PRINT(..\Obj\matrix_key.lst) OBJECT(..\Obj\matrix_key.obj)

line level    source

   1          #include "matrix_key.h"
   2          
   3          #if USE_MATRIX_KEY_TIMER0
              /*******************************
              函数名：matrix_key_timer0_config
              函数功能：定时器0的配置
              函数形参：void
              函数返回值：void
              备注：
              *******************************/
              void matrix_key_timer0_config()  //11.0592MHz
              {
                      TMOD &= 0xf0;
                      TMOD |= 0x01;  // 计数器0工作在模式1
                      TR0 = 1;  // 计数器0工作
                      TH0 = 0xf8;   
                      TL0 = 0xcd;  // 65536-63693=1843, 2ms
                      EA = 1;
                      ET0 = 1;  // 打开中断
              }
              #endif
  22          
  23          /*******************************
  24          函数名：matrix_key_scan
  25          函数功能：矩阵按键的扫描，按下(250Hz)或者长按开始时(500Hz)有音效
  26          函数形参：void
  27          函数返回值：u8 
  28          备注：返回值为1~16，
  29          1  2  3  4
  30          5  6  7  8
  31          9  10 11 12
  32          13 14 15 16
  33          长按则在原来基础上+16
  34          没有结果则返回0xff
  35          *******************************/
  36          bit flag_matrix_key = 0;
  37          unsigned char flag_matrix_key_pressed = 0;
  38          unsigned char matrix_key_hold_cnt=0;
  39          bit flag_key_long_press_output_500ms = 0;
  40          bit flag_buzzer_250Hz=0;
  41          bit flag_buzzer_500Hz=0;
  42          unsigned char matrix_key_scan()
  43          {
  44   1              unsigned char key_value=0xff;
  45   1              static unsigned char j=0, k=0;
  46   1              static xdata unsigned char key_flag[4]={0,0,0,0};  // 倒数第几位为0表示第几个按键没按下
  47   1              static xdata unsigned char buff[4][4]={{0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff},{0xff,0xff,0xff,0xff},
             -{0xff,0xff,0xff,0xff}};  // 消抖，连续采样8次，8次采样值均相同才视为稳定
  48   1              static xdata unsigned char key_press_no[4]={0,0,0,0};  // 单击后记录是哪个按键单击，没有则为0
  49   1              static xdata unsigned char key_hold_no[4]={0,0,0,0};  // 已经长按的按键，没有则为0
  50   1              unsigned char i;
  51   1      
  52   1              switch(j)  // 换行扫描，对应行输入置0，低电平
  53   1              {
C51 COMPILER V9.02   MATRIX_KEY                                                            12/16/2022 23:19:34 PAGE 2   

  54   2                      case 0: P1 = 0x7f; break;
  55   2                      case 1: P1 = 0xbf; break;
  56   2                      case 2: P1 = 0xdf; break;
  57   2                      case 3: P1 = 0xef; break;
  58   2              }
  59   1      
  60   1              if (flag_matrix_key == 1)  // 每2ms检测一次
  61   1              {
  62   2                      flag_matrix_key = 0;
  63   2                      buff[j][0] = (buff[j][0]<<1) | matrix_key_col_1;
  64   2                      buff[j][1] = (buff[j][1]<<1) | matrix_key_col_2;
  65   2                      buff[j][2] = (buff[j][2]<<1) | matrix_key_col_3;
  66   2                      buff[j][3] = (buff[j][3]<<1) | matrix_key_col_4;                
  67   2      
  68   2                      for (i=0;i<4;i++)  //循环检测四个按键
  69   2                      {
  70   3                              if ( ((key_flag[j]>>i)&0x01)==0x00 && buff[j][i]==0x00 )  // 当前flag没按下，buff已经稳定
  71   3                              {
  72   4                                      key_flag[j] |= 0x01<<i;  // 置1，表示按键按下
  73   4                                      key_value = 4*j+i + 1;
  74   4                              }
  75   3                              else if (buff[j][i]==0xff) key_flag[j] &= ~(0x01<<i);  // 置0，表示按键松开
  76   3                      }
  77   2      
  78   2                      // 判断长按             
  79   2                      if (key_hold_no[k]!=0)  // 已经有按键处于长按状态
  80   2                      {
  81   3                              if (key_value != key_hold_no[k])        // 键值跟之前不一样或者没有按键按下
  82   3                              {
  83   4                                      key_hold_no[k] = 0;
  84   4                                      key_press_no[k] = 0;    
  85   4                              }
  86   3                              else  // 仍然长按中
  87   3                              {
  88   4                                      key_value = key_hold_no[k] + 16;
  89   4                                      key_flag[j] &= ~(0x01<<((key_value-1)%4));      // 置0，表示按键松开，才能再次检测单击
  90   4                              }
  91   3                      } else if (key_value!=0xff)      // 目前没有长按且有按键按下
  92   2                      {       
  93   3                              if ( ( (flag_matrix_key_pressed>>k)&0x01 ) == 0 )        // 为0，第一次单击
  94   3                              {
  95   4                                      key_press_no[k] = key_value;  // 记录单击的按键
  96   4                                      matrix_key_hold_cnt = 0;  // 清零计数器
  97   4                                      flag_matrix_key_pressed |= (1<<k);  // 置1，计数器开始计数
  98   4                                      key_flag[j] &= ~(0x01<<((key_value-1)%4));      // 置0，表示按键松开，才能再次检测单击
  99   4                              }else  // 之前已经单击了
 100   3                              {
 101   4                                      if (key_value == key_press_no[k])  // 单击过了同一按键
 102   4                                      {
 103   5                                              key_flag[j] &= ~(0x01<<((key_value-1)%4));      // 置0，表示按键松开，才能再次检测单击
 104   5                                              key_value = 0xff;  // 单击过了不再返回键值
 105   5                                      } else  // 新的单击
 106   4                                      {
 107   5                                              key_press_no[k] = key_value;  // 记录单击的按键
 108   5                                              matrix_key_hold_cnt = 0;  // 清零计数器重新开始计数
 109   5                                              key_flag[j] &= ~(0x01<<((key_value-1)%4));      // 置0，表示按键松开，才能再次检测单击
 110   5                                      }
 111   4                              }
 112   3                              
 113   3                              if (matrix_key_hold_cnt>=250)  // 判断为长按，500ms
 114   3                              {
 115   4                                      flag_matrix_key_pressed &= ~(1<<k);  // 置0，停止计数
C51 COMPILER V9.02   MATRIX_KEY                                                            12/16/2022 23:19:34 PAGE 3   

 116   4                                      key_hold_no[k] = key_press_no[k];
 117   4                                      key_value = key_hold_no[k] + 16;  // 返回键值+16代表长按
 118   4                                      flag_buzzer_500Hz = 1;  // 长按开始时音效                                                       
 119   4                              }
 120   3                      } else  // 0xff，松开
 121   2                      {
 122   3                              key_hold_no[k] = 0;
 123   3                              key_press_no[k] = 0;
 124   3                              flag_matrix_key_pressed &= ~(1<<k);     
 125   3                      }
 126   2      
 127   2                      if (key_value>=17 && key_value<=32)  // 长按每0.5s输出一次键值
 128   2                      {
 129   3                              if (flag_key_long_press_output_500ms == 1)
 130   3                                      flag_key_long_press_output_500ms = 0;
 131   3                              else key_value = 0xff; 
 132   3                      }
 133   2      
 134   2                      k++;
 135   2                      if (k==4) k = 0;  // 长按检测，每四次才会扫描同一行             
 136   2                      j++;
 137   2                      if (j==4) j = 0;  // 换行扫描
 138   2              }
 139   1      
 140   1              if (key_value < 17) flag_buzzer_250Hz = 1;      // 单击音效
 141   1              return key_value;
 142   1      } 
 143          
 144          #if     USE_MATRIX_KEY_TIMER0_INT
              /*******************************
              函数名：matrix_key_timer0_interrupt
              函数功能：定时器0的中断服务函数
              函数形参：void
              函数返回值：void
              备注：
              *******************************/
              void matrix_key_timer0_interrupt() interrupt 1
              {
                      TH0 = 0xf8;   
                      TL0 = 0xcd;
                      flag_matrix_key = 1;
                      if (flag_matrix_key_pressed!=0)
                              matrix_key_hold_cnt++;
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    804    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     28    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
